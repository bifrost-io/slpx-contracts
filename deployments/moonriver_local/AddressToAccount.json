{
  "address": "0xCf7Ed3AccA5a467e9e704C703E8D87F634fB0Fc9",
  "abi": [
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "addr",
          "type": "address"
        }
      ],
      "name": "AddressToSubstrateAccount",
      "outputs": [
        {
          "internalType": "bytes32",
          "name": "account",
          "type": "bytes32"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes",
          "name": "src",
          "type": "bytes"
        }
      ],
      "name": "blake2bHash",
      "outputs": [
        {
          "internalType": "bytes32",
          "name": "des",
          "type": "bytes32"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    }
  ],
  "transactionHash": "0x5eb9566e46511e8f4275dfe3fb1b11af27d2fa9418e8686ff567b8222db513b7",
  "receipt": {
    "to": null,
    "from": "0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266",
    "contractAddress": "0xCf7Ed3AccA5a467e9e704C703E8D87F634fB0Fc9",
    "transactionIndex": 0,
    "gasUsed": "464822",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "blockHash": "0xf76edc1998d09a182c808cf33fa9412e0766b606c7fa922d4c99aa9f8730ee89",
    "transactionHash": "0x5eb9566e46511e8f4275dfe3fb1b11af27d2fa9418e8686ff567b8222db513b7",
    "logs": [],
    "blockNumber": 106,
    "cumulativeGasUsed": "464822",
    "status": 1,
    "byzantium": true
  },
  "args": [],
  "numDeployments": 1,
  "solcInputHash": "6c896790ddad93907504aded3a7e1058",
  "metadata": "{\"compiler\":{\"version\":\"0.8.10+commit.fc410830\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"AddressToSubstrateAccount\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"account\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"src\",\"type\":\"bytes\"}],\"name\":\"blake2bHash\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"des\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/utils/AddressToAccount.sol\":\"AddressToAccount\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":200},\"remappings\":[]},\"sources\":{\"contracts/utils/AddressToAccount.sol\":{\"content\":\"// SPDX-License-Identifier: Apache-2.0\\npragma solidity ^0.8.0;\\n\\nimport \\\"./Blake2b.sol\\\";\\n\\nlibrary AddressToAccount {\\n    using Blake2b for Blake2b.Instance;\\n\\n    function blake2bHash(bytes memory src) public view returns (bytes32 des) {\\n        Blake2b.Instance memory instance = Blake2b.init(hex\\\"\\\", 32);\\n        return abi.decode(instance.finalize(src), (bytes32));\\n    }\\n\\n    function AddressToSubstrateAccount(\\n        address addr\\n    ) public view returns (bytes32 account) {\\n        bytes memory prefix = bytes(\\\"evm:\\\");\\n        bytes memory addrBytes = abi.encodePacked(addr);\\n        bytes memory data = abi.encodePacked(prefix, addrBytes);\\n        return blake2bHash(data);\\n    }\\n}\\n\",\"keccak256\":\"0xfa01044cb7e521da112383416c0f7772eba453695dff7527c7baa8329282c9ab\",\"license\":\"Apache-2.0\"},\"contracts/utils/Blake2b.sol\":{\"content\":\"// SPDX-License-Identifier: Apache-2.0\\npragma solidity ^0.8.0;\\npragma experimental ABIEncoderV2;\\n\\nlibrary Blake2b {\\n    struct Instance {\\n        // This is a bit misleadingly called state as it not only includes the Blake2 state,\\n        // but every field needed for the \\\"blake2 f function precompile\\\".\\n        //\\n        // This is a tightly packed buffer of:\\n        // - rounds: 32-bit BE\\n        // - h: 8 x 64-bit LE\\n        // - m: 16 x 64-bit LE\\n        // - t: 2 x 64-bit LE\\n        // - f: 8-bit\\n        bytes state;\\n        // Expected output hash length. (Used in `finalize`.)\\n        uint out_len;\\n        // Data passed to \\\"function F\\\".\\n        // NOTE: this is limited to 24 bits.\\n        uint input_counter;\\n    }\\n\\n    // Initialise the state with a given `key` and required `out_len` hash length.\\n    function init(\\n        bytes memory key,\\n        uint out_len\\n    ) internal view returns (Instance memory instance) {\\n        reset(instance, key, out_len);\\n    }\\n\\n    // Initialise the state with a given `key` and required `out_len` hash length.\\n    function reset(\\n        Instance memory instance,\\n        bytes memory key,\\n        uint out_len\\n    ) internal view {\\n        instance.out_len = out_len;\\n        instance.input_counter = 0;\\n\\n        // This is entire state transmitted to the precompile.\\n        // It is byteswapped for the encoding requirements, additionally\\n        // the IV has the initial parameter block 0 XOR constant applied, but\\n        // not the key and output length.\\n        instance\\n            .state = hex\\\"0000000c08c9bdf267e6096a3ba7ca8485ae67bb2bf894fe72f36e3cf1361d5f3af54fa5d182e6ad7f520e511f6c3e2b8c68059b6bbd41fbabd9831f79217e1319cde05b00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\\\";\\n        bytes memory state = instance.state;\\n\\n        // Update parameter block 0 with key length and output length.\\n        uint key_len = key.length;\\n        assembly {\\n            let ptr := add(state, 36)\\n            let tmp := mload(ptr)\\n            let p0 := or(shl(240, key_len), shl(248, out_len))\\n            tmp := xor(tmp, p0)\\n            mstore(ptr, tmp)\\n        }\\n\\n        // TODO: support salt and personalization\\n\\n        if (key_len > 0) {\\n            require(key_len == 64);\\n            // FIXME: the key must be zero padded\\n            assert(key.length == 128);\\n            update(instance, key, key_len);\\n        }\\n    }\\n\\n    // This calls the blake2 precompile (\\\"function F of the spec\\\").\\n    // It expects the state was updated with the next block. Upon returning the state will be updated,\\n    // but the supplied block data will not be cleared.\\n    function call_function_f(Instance memory instance) private view {\\n        bytes memory state = instance.state;\\n        assembly {\\n            let state_ptr := add(state, 32)\\n            if iszero(\\n                staticcall(\\n                    not(0),\\n                    0x09,\\n                    state_ptr,\\n                    0xd5,\\n                    add(state_ptr, 4),\\n                    0x40\\n                )\\n            ) {\\n                revert(0, 0)\\n            }\\n        }\\n    }\\n\\n    // This function will split blocks correctly and repeatedly call the precompile.\\n    // NOTE: this is dumb right now and expects `data` to be 128 bytes long and padded with zeroes,\\n    //       hence the real length is indicated with `data_len`\\n    function update_loop(\\n        Instance memory instance,\\n        bytes memory data,\\n        uint data_len,\\n        bool last_block\\n    ) private view {\\n        bytes memory state = instance.state;\\n        uint input_counter = instance.input_counter;\\n\\n        // This is the memory location where the \\\"data block\\\" starts for the precompile.\\n        uint state_ptr;\\n        assembly {\\n            // The `rounds` field is 4 bytes long and the `h` field is 64-bytes long.\\n            // Also adjust for the size of the bytes type.\\n            state_ptr := add(state, 100)\\n        }\\n\\n        // This is the memory location where the input data resides.\\n        uint data_ptr;\\n        assembly {\\n            data_ptr := add(data, 32)\\n        }\\n\\n        uint len = data.length;\\n        while (len > 0) {\\n            if (len >= 128) {\\n                assembly {\\n                    mstore(state_ptr, mload(data_ptr))\\n                    data_ptr := add(data_ptr, 32)\\n\\n                    mstore(add(state_ptr, 32), mload(data_ptr))\\n                    data_ptr := add(data_ptr, 32)\\n\\n                    mstore(add(state_ptr, 64), mload(data_ptr))\\n                    data_ptr := add(data_ptr, 32)\\n\\n                    mstore(add(state_ptr, 96), mload(data_ptr))\\n                    data_ptr := add(data_ptr, 32)\\n                }\\n\\n                len -= 128;\\n                // FIXME: remove this once implemented proper padding\\n                if (data_len < 128) {\\n                    input_counter += data_len;\\n                } else {\\n                    data_len -= 128;\\n                    input_counter += 128;\\n                }\\n            } else {\\n                // FIXME: implement support for smaller than 128 byte blocks\\n                revert();\\n            }\\n\\n            // Set length field (little-endian) for maximum of 24-bits.\\n            assembly {\\n                mstore8(add(state, 228), and(input_counter, 0xff))\\n                mstore8(add(state, 229), and(shr(8, input_counter), 0xff))\\n                mstore8(add(state, 230), and(shr(16, input_counter), 0xff))\\n            }\\n\\n            // Set the last block indicator.\\n            // Only if we've processed all input.\\n            if (len == 0) {\\n                assembly {\\n                    // Writing byte 212 here.\\n                    mstore8(add(state, 244), last_block)\\n                }\\n            }\\n\\n            // Call the precompile\\n            call_function_f(instance);\\n        }\\n\\n        instance.input_counter = input_counter;\\n    }\\n\\n    // Update the state with a non-final block.\\n    // NOTE: the input must be complete blocks.\\n    function update(\\n        Instance memory instance,\\n        bytes memory data,\\n        uint data_len\\n    ) internal view {\\n        require((data.length % 128) == 0);\\n        update_loop(instance, data, data_len, false);\\n    }\\n\\n    // Update the state with a final block and return the hash.\\n    function finalize(\\n        Instance memory instance,\\n        bytes memory data\\n    ) internal view returns (bytes memory output) {\\n        // FIXME: support incomplete blocks (zero pad them)\\n        uint input_length = data.length;\\n        if (input_length == 0 || (input_length % 128) != 0) {\\n            data = abi.encodePacked(\\n                data,\\n                new bytes(128 - (input_length % 128))\\n            );\\n        }\\n        assert((data.length % 128) == 0);\\n        update_loop(instance, data, input_length, true);\\n\\n        // FIXME: support other lengths\\n        // assert(instance.out_len == 64);\\n\\n        bytes memory state = instance.state;\\n        output = new bytes(instance.out_len);\\n        if (instance.out_len == 16) {\\n            assembly {\\n                mstore(add(output, 16), mload(add(state, 20)))\\n                mstore(output, 16)\\n            }\\n        } else if (instance.out_len == 32) {\\n            assembly {\\n                mstore(add(output, 32), mload(add(state, 36)))\\n            }\\n        } else {\\n            assembly {\\n                mstore(add(output, 32), mload(add(state, 36)))\\n                mstore(add(output, 64), mload(add(state, 68)))\\n            }\\n        }\\n    }\\n\\n    function concat(\\n        bytes memory _preBytes,\\n        bytes memory _postBytes\\n    ) internal pure returns (bytes memory) {\\n        bytes memory tempBytes;\\n\\n        assembly {\\n            // Get a location of some free memory and store it in tempBytes as\\n            // Solidity does for memory variables.\\n            tempBytes := mload(0x40)\\n\\n            // Store the length of the first bytes array at the beginning of\\n            // the memory for tempBytes.\\n            let length := mload(_preBytes)\\n            mstore(tempBytes, length)\\n\\n            // Maintain a memory counter for the current write location in the\\n            // temp bytes array by adding the 32 bytes for the array length to\\n            // the starting location.\\n            let mc := add(tempBytes, 0x20)\\n            // Stop copying when the memory counter reaches the length of the\\n            // first bytes array.\\n            let end := add(mc, length)\\n\\n            for {\\n                // Initialize a copy counter to the start of the _preBytes data,\\n                // 32 bytes into its memory.\\n                let cc := add(_preBytes, 0x20)\\n            } lt(mc, end) {\\n                // Increase both counters by 32 bytes each iteration.\\n                mc := add(mc, 0x20)\\n                cc := add(cc, 0x20)\\n            } {\\n                // Write the _preBytes data into the tempBytes memory 32 bytes\\n                // at a time.\\n                mstore(mc, mload(cc))\\n            }\\n\\n            // Add the length of _postBytes to the current length of tempBytes\\n            // and store it as the new length in the first 32 bytes of the\\n            // tempBytes memory.\\n            length := mload(_postBytes)\\n            mstore(tempBytes, add(length, mload(tempBytes)))\\n\\n            // Move the memory counter back from a multiple of 0x20 to the\\n            // actual end of the _preBytes data.\\n            mc := end\\n            // Stop copying when the memory counter reaches the new combined\\n            // length of the arrays.\\n            end := add(mc, length)\\n\\n            for {\\n                let cc := add(_postBytes, 0x20)\\n            } lt(mc, end) {\\n                mc := add(mc, 0x20)\\n                cc := add(cc, 0x20)\\n            } {\\n                mstore(mc, mload(cc))\\n            }\\n\\n            // Update the free-memory pointer by padding our last write location\\n            // to 32 bytes: add 31 bytes to the end of tempBytes to move to the\\n            // next 32 byte block, then round down to the nearest multiple of\\n            // 32. If the sum of the length of the two arrays is zero then add\\n            // one before rounding down to leave a blank 32 bytes (the length block with 0).\\n            mstore(\\n                0x40,\\n                and(\\n                    add(add(end, iszero(add(length, mload(_preBytes)))), 31),\\n                    not(31) // Round down to the nearest 32 bytes.\\n                )\\n            )\\n        }\\n\\n        return tempBytes;\\n    }\\n}\\n\",\"keccak256\":\"0xa1d82bbed563d73f2e0d99477a3fb774d4fddba2a8f4a066681b6e4856f60016\",\"license\":\"Apache-2.0\"}},\"version\":1}",
  "bytecode": "0x61077961003a600b82828239805160001a60731461002d57634e487b7160e01b600052600060045260246000fd5b30600052607381538281f3fe73000000000000000000000000000000000000000030146080604052600436106100405760003560e01c806332640a521461004557806336e7c7621461006a575b600080fd5b610058610053366004610490565b61007d565b60405190815260200160405180910390f35b6100586100783660046104cf565b610113565b6000806040518060400160405280600481526020016332bb369d60e11b81525090506000836040516020016100ca919060609190911b6bffffffffffffffffffffffff1916815260140190565b6040516020818303038152906040529050600082826040516020016100f09291906105bb565b604051602081830303815290604052905061010a81610113565b95945050505050565b600080610130604051806020016040528060008152506020610156565b905061013c818461018b565b80602001905181019061014f91906105d8565b9392505050565b61017a60405180606001604052806060815260200160008152602001600081525090565b6101858184846102f5565b92915050565b80516060908015806101a657506101a36080826105f1565b15155b1561022857826101b76080836105f1565b6101c2906080610629565b67ffffffffffffffff8111156101da576101da6104b9565b6040519080825280601f01601f191660200182016040528015610204576020820181803683370190505b506040516020016102169291906105bb565b60405160208183030381529060405292505b6080835161023691906105f1565b1561024357610243610640565b6102508484836001610373565b8351602085015167ffffffffffffffff81111561026f5761026f6104b9565b6040519080825280601f01601f191660200182016040528015610299576020820181803683370190505b5092508460200151601014156102bc5760148101516010840152601083526102ed565b8460200151602014156102d857602481015160208401526102ed565b60248101516020840152604481015160408401525b505092915050565b80836020018181525050600083604001818152505060405180610100016040528060d5815260200161066f60d59139808452825160248201805160f083901b60f886901b17189052801561036c578060401461035057600080fd5b835160801461036157610361610640565b61036c858583610448565b5050505050565b835160408501518451606483019060208701905b8015610436576080811061004057815183526020808301519084015260408083015190840152606080830151908401526080918201916103c79082610629565b905060808710156103e3576103dc8785610656565b93506103fb565b6103ee608088610629565b96506103dc608085610656565b60ff841660e486015360ff8460081c1660e586015360ff8460101c1660e686015380610428578560f48601535b61043189610472565b610387565b50505060409095019490945250505050565b6080825161045691906105f1565b1561046057600080fd5b61046d8383836000610373565b505050565b80516020810160406024830160d5836009600019fa61046d57600080fd5b6000602082840312156104a257600080fd5b81356001600160a01b038116811461014f57600080fd5b634e487b7160e01b600052604160045260246000fd5b6000602082840312156104e157600080fd5b813567ffffffffffffffff808211156104f957600080fd5b818401915084601f83011261050d57600080fd5b81358181111561051f5761051f6104b9565b604051601f8201601f19908116603f01168101908382118183101715610547576105476104b9565b8160405282815287602084870101111561056057600080fd5b826020860160208301376000928101602001929092525095945050505050565b6000815160005b818110156105a15760208185018101518683015201610587565b818111156105b0576000828601525b509290920192915050565b60006105d06105ca8386610580565b84610580565b949350505050565b6000602082840312156105ea57600080fd5b5051919050565b60008261060e57634e487b7160e01b600052601260045260246000fd5b500690565b634e487b7160e01b600052601160045260246000fd5b60008282101561063b5761063b610613565b500390565b634e487b7160e01b600052600160045260246000fd5b6000821982111561066957610669610613565b50019056fe0000000c08c9bdf267e6096a3ba7ca8485ae67bb2bf894fe72f36e3cf1361d5f3af54fa5d182e6ad7f520e511f6c3e2b8c68059b6bbd41fbabd9831f79217e1319cde05b00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000a2646970667358221220b0e6b3b152a4f603a1342fbba90b9ee1cf134ae813a8b6e40858de84b72bade764736f6c634300080a0033",
  "deployedBytecode": "0x73000000000000000000000000000000000000000030146080604052600436106100405760003560e01c806332640a521461004557806336e7c7621461006a575b600080fd5b610058610053366004610490565b61007d565b60405190815260200160405180910390f35b6100586100783660046104cf565b610113565b6000806040518060400160405280600481526020016332bb369d60e11b81525090506000836040516020016100ca919060609190911b6bffffffffffffffffffffffff1916815260140190565b6040516020818303038152906040529050600082826040516020016100f09291906105bb565b604051602081830303815290604052905061010a81610113565b95945050505050565b600080610130604051806020016040528060008152506020610156565b905061013c818461018b565b80602001905181019061014f91906105d8565b9392505050565b61017a60405180606001604052806060815260200160008152602001600081525090565b6101858184846102f5565b92915050565b80516060908015806101a657506101a36080826105f1565b15155b1561022857826101b76080836105f1565b6101c2906080610629565b67ffffffffffffffff8111156101da576101da6104b9565b6040519080825280601f01601f191660200182016040528015610204576020820181803683370190505b506040516020016102169291906105bb565b60405160208183030381529060405292505b6080835161023691906105f1565b1561024357610243610640565b6102508484836001610373565b8351602085015167ffffffffffffffff81111561026f5761026f6104b9565b6040519080825280601f01601f191660200182016040528015610299576020820181803683370190505b5092508460200151601014156102bc5760148101516010840152601083526102ed565b8460200151602014156102d857602481015160208401526102ed565b60248101516020840152604481015160408401525b505092915050565b80836020018181525050600083604001818152505060405180610100016040528060d5815260200161066f60d59139808452825160248201805160f083901b60f886901b17189052801561036c578060401461035057600080fd5b835160801461036157610361610640565b61036c858583610448565b5050505050565b835160408501518451606483019060208701905b8015610436576080811061004057815183526020808301519084015260408083015190840152606080830151908401526080918201916103c79082610629565b905060808710156103e3576103dc8785610656565b93506103fb565b6103ee608088610629565b96506103dc608085610656565b60ff841660e486015360ff8460081c1660e586015360ff8460101c1660e686015380610428578560f48601535b61043189610472565b610387565b50505060409095019490945250505050565b6080825161045691906105f1565b1561046057600080fd5b61046d8383836000610373565b505050565b80516020810160406024830160d5836009600019fa61046d57600080fd5b6000602082840312156104a257600080fd5b81356001600160a01b038116811461014f57600080fd5b634e487b7160e01b600052604160045260246000fd5b6000602082840312156104e157600080fd5b813567ffffffffffffffff808211156104f957600080fd5b818401915084601f83011261050d57600080fd5b81358181111561051f5761051f6104b9565b604051601f8201601f19908116603f01168101908382118183101715610547576105476104b9565b8160405282815287602084870101111561056057600080fd5b826020860160208301376000928101602001929092525095945050505050565b6000815160005b818110156105a15760208185018101518683015201610587565b818111156105b0576000828601525b509290920192915050565b60006105d06105ca8386610580565b84610580565b949350505050565b6000602082840312156105ea57600080fd5b5051919050565b60008261060e57634e487b7160e01b600052601260045260246000fd5b500690565b634e487b7160e01b600052601160045260246000fd5b60008282101561063b5761063b610613565b500390565b634e487b7160e01b600052600160045260246000fd5b6000821982111561066957610669610613565b50019056fe0000000c08c9bdf267e6096a3ba7ca8485ae67bb2bf894fe72f36e3cf1361d5f3af54fa5d182e6ad7f520e511f6c3e2b8c68059b6bbd41fbabd9831f79217e1319cde05b00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000a2646970667358221220b0e6b3b152a4f603a1342fbba90b9ee1cf134ae813a8b6e40858de84b72bade764736f6c634300080a0033",
  "devdoc": {
    "kind": "dev",
    "methods": {},
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {},
    "version": 1
  },
  "storageLayout": {
    "storage": [],
    "types": null
  }
}